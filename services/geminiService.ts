import { GoogleGenAI, Type, Content, Part } from "@google/genai";
import type { DrawnCard, Spread, TarotCard, AlmanacInfo, InterpretationLayer, InterpretedCard } from '../types';

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  console.error("Gemini API key is missing. The application will not be able to generate interpretations or images. Please set the API_KEY environment variable.");
}

const ai = API_KEY ? new GoogleGenAI({ apiKey: API_KEY }) : null;

const ensureAi = (): GoogleGenAI => {
    if (!ai) {
        throw new Error("Configuration error: Gemini API key is not available.");
    }
    return ai;
}

/**
 * Parses a raw error from the Gemini API and returns a user-friendly message.
 * @param error The unknown error object.
 * @param defaultMessage A fallback message.
 * @returns A user-friendly error string.
 */
function parseGeminiError(error: unknown, defaultMessage: string = "An unexpected error occurred."): string {
    console.error("Gemini API Error:", error);
    if (error instanceof Error) {
        const message = error.message.toLowerCase();
        if (message.includes("api key not valid")) {
            return "Configuration Error: The Gemini API key is invalid or missing. Please check the application setup.";
        }
        if (message.includes("billing") || message.includes("quota")) {
            return "API Limit Reached: The request could not be completed due to billing or quota limits.";
        }
        if (message.includes("safety") || message.includes("blocked")) {
            return "Content Warning: The request or response was blocked due to safety settings. Please adjust your prompt.";
        }
        if (message.includes("resource has been exhausted") || message.includes("429")) {
             return "API Busy: The service is currently experiencing high traffic. Please try again in a moment.";
        }
        // Attempt to strip "[GoogleGenerativeAI Error]" prefix for a cleaner message
        const googleErrorMatch = message.match(/\[\w+ \w+\](.*)/);
        if (googleErrorMatch && googleErrorMatch[1]) {
            const cleanMessage = googleErrorMatch[1].trim();
            return `An error occurred: ${cleanMessage.charAt(0).toUpperCase() + cleanMessage.slice(1)}.`;
        }
        return error.message; // Fallback to the raw error message if it's not a standard Google AI error
    }
    return defaultMessage;
}


export const generateCardImage = async (card: TarotCard): Promise<string> => {
  const aiInstance = ensureAi();
  const prompt = `A mystical tarot card illustration of '${card.name}'. 
Style: ethereal, magical realism, detailed linework, art nouveau influences, rich symbolism related to its meaning. 
Keywords: ${card.uprightKeywords.join(', ')}. 
The image should be vertical. Do not include any text, letters, or borders on the card art itself.`;

  try {
    const response = await aiInstance.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        outputMimeType: 'image/png',
        aspectRatio: '3:4',
      },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
      const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
      return `data:image/png;base64,${base64ImageBytes}`;
    } else {
      throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    const friendlyMessage = parseGeminiError(error, `Failed to generate image for ${card.name}.`);
    throw new Error(friendlyMessage);
  }
};

export const identifyCardFromImage = async (base64Image: string): Promise<string> => {
  const aiInstance = ensureAi();
  const imageParts = base64Image.split(',');
  if (imageParts.length !== 2) {
    throw new Error("Invalid base64 image format provided.");
  }
  const mimeType = imageParts[0].match(/:(.*?);/)?.[1] || 'image/jpeg';
  const imageData = imageParts[1];

  const imagePart: Part = {
    inlineData: {
      mimeType,
      data: imageData,
    },
  };
  const textPart: Part = {
    text: "Identify the tarot card in this image. Respond in JSON format with a single key 'cardName' containing the card's full name. For example: {\"cardName\": \"The Fool\"}",
  };

  const contents: Content = { parts: [imagePart, textPart] };

  try {
    const response = await aiInstance.models.generateContent({
      model: 'gemini-2.5-flash',
      contents,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            cardName: {
              type: Type.STRING,
              description: "The identified name of the tarot card."
            },
          },
          required: ["cardName"]
        },
      },
    });
    const result = JSON.parse(response.text);
    if (result && typeof result.cardName === 'string') {
      return result.cardName.trim();
    } else {
      throw new Error("AI response did not contain a valid card name.");
    }
  } catch (error) {
    if (error instanceof SyntaxError) {
        throw new Error("The AI returned an unexpected response format. Please try again.");
    }
    const friendlyMessage = parseGeminiError(error, "Failed to identify the card from the provided image.");
    throw new Error(friendlyMessage);
  }
};


function formatCardsForPrompt(drawnCards: DrawnCard[]): string {
  return drawnCards.map((c, i) => 
    `Card ${i + 1}: ${c.card.name} (${c.isReversed ? 'Reversed' : 'Upright'})`
  ).join('\n');
}

export const getInterpretation = async (
  drawnCards: DrawnCard[],
  spread: Spread,
  question: string,
  almanacInfo: AlmanacInfo
): Promise<{ overall: InterpretationLayer; cards: InterpretedCard[] }> => {
  const aiInstance = ensureAi();
  const cardDetails = formatCardsForPrompt(drawnCards);
  const positionDetails = spread.positions.map((p, i) => `Position ${i+1} (${p.title}): ${p.description}`).join('\n');
  const userQuestion = question ? `The user's specific question is paramount: "${question}"` : "This is a general reading for overall guidance.";

  const almanacContext = `
**Contextual Information (subtly weave these in):**
- **Lunar Phase:** ${almanacInfo.lunarPhase}
- **Season:** ${almanacInfo.season}
- **Holiday/Sabbat:** ${almanacInfo.holiday || 'None'}
`;

  const contents = `
You are a wise, compassionate, and mystical Tarot guide. Your tone is empowering and insightful. Frame challenges as lessons. The user's question is the most important part of the context.

**Reading Details:**
- **Spread:** ${spread.name}
- **Focus:** ${userQuestion}
${almanacContext}
**Cards Drawn:**
${cardDetails}
**Spread Positions:**
${positionDetails}

Provide an interpretation in JSON. It must have two keys: "overall" and "cards".

1.  "overall": An object with three distinct layers of meaning for the entire reading:
    - "outer": The practical, real-world advice and likely outcomes (2 sentences).
    - "inner": The psychological, emotional, or internal landscape this reading reflects (2 sentences).
    - "whispers": The spiritual lesson or intuitive, higher-perspective guidance (1-2 sentences).

2.  "cards": An array of objects, one for each card. Each object must have:
    - "cardName": The name of the card.
    - "outer": The card's practical meaning in its specific position, answering the user's question.
    - "inner": The card's psychological or emotional message in this position.
    - "whispers": The card's spiritual or intuitive guidance in this position.

Keep each card layer interpretation concise (1-2 sentences).
`;
    const layerSchema = {
        type: Type.OBJECT,
        properties: {
            outer: {
                type: Type.STRING,
                description: "The practical, real-world advice and likely outcomes."
            },
            inner: {
                type: Type.STRING,
                description: "The psychological, emotional, or internal landscape this reading reflects."
            },
            whispers: {
                type: Type.STRING,
                description: "The spiritual lesson or intuitive, higher-perspective guidance."
            }
        },
        required: ["outer", "inner", "whispers"]
    };

  try {
    const response = await aiInstance.models.generateContent({
      model: "gemini-2.5-flash",
      contents,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            overall: layerSchema,
            cards: {
              type: Type.ARRAY,
              description: "An array of layered interpretations for each card drawn.",
              items: {
                type: Type.OBJECT,
                properties: {
                  cardName: {
                    type: Type.STRING,
                    description: "The name of the card."
                  },
                  outer: {
                    type: Type.STRING,
                    description: "The card's practical meaning in its specific position."
                  },
                  inner: {
                    type: Type.STRING,
                    description: "The card's psychological or emotional message in this position."
                  },
                  whispers: {
                    type: Type.STRING,
                    description: "The card's spiritual or intuitive guidance in this position."
                  }
                },
                required: ["cardName", "outer", "inner", "whispers"]
              }
            }
          },
          required: ["overall", "cards"]
        },
      },
    });

    const jsonText = response.text;
    const result = JSON.parse(jsonText);

    if (result && result.overall && Array.isArray(result.cards)) {
      return result;
    } else {
      throw new Error("Invalid JSON structure received from API.");
    }

  } catch (error) {
    if (error instanceof SyntaxError) { // JSON.parse error
        throw new Error("The AI returned an unreadable response. This might be a temporary issue. Please try again.");
    }
    const friendlyMessage = parseGeminiError(error, "The Tarot spirits are busy. Please try again in a moment.");
    throw new Error(friendlyMessage);
  }
};