import { GoogleGenAI, Type, Content, Part } from "@google/genai";
import type { DrawnCard, Spread, TarotCard, AlmanacInfo } from '../types';

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  console.error("Gemini API key is missing. The application will not be able to generate interpretations or images. Please set the API_KEY environment variable.");
}

const ai = API_KEY ? new GoogleGenAI({ apiKey: API_KEY }) : null;

const ensureAi = (): GoogleGenAI => {
    if (!ai) {
        throw new Error("Configuration error: Gemini API key is not available.");
    }
    return ai;
}

/**
 * Parses a raw error from the Gemini API and returns a user-friendly message.
 * @param error The unknown error object.
 * @param defaultMessage A fallback message.
 * @returns A user-friendly error string.
 */
function parseGeminiError(error: unknown, defaultMessage: string = "An unexpected error occurred."): string {
    console.error("Gemini API Error:", error);
    if (error instanceof Error) {
        const message = error.message.toLowerCase();
        if (message.includes("api key not valid")) {
            return "Configuration Error: The Gemini API key is invalid or missing. Please check the application setup.";
        }
        if (message.includes("billing") || message.includes("quota")) {
            return "API Limit Reached: The request could not be completed due to billing or quota limits.";
        }
        if (message.includes("safety") || message.includes("blocked")) {
            return "Content Warning: The request or response was blocked due to safety settings. Please adjust your prompt.";
        }
        if (message.includes("resource has been exhausted") || message.includes("429")) {
             return "API Busy: The service is currently experiencing high traffic. Please try again in a moment.";
        }
        // Attempt to strip "[GoogleGenerativeAI Error]" prefix for a cleaner message
        const googleErrorMatch = message.match(/\[\w+ \w+\](.*)/);
        if (googleErrorMatch && googleErrorMatch[1]) {
            const cleanMessage = googleErrorMatch[1].trim();
            return `An error occurred: ${cleanMessage.charAt(0).toUpperCase() + cleanMessage.slice(1)}.`;
        }
        return error.message; // Fallback to the raw error message if it's not a standard Google AI error
    }
    return defaultMessage;
}


export const generateCardImage = async (card: TarotCard): Promise<string> => {
  const aiInstance = ensureAi();
  const prompt = `A mystical tarot card illustration of '${card.name}'. 
Style: ethereal, magical realism, detailed linework, art nouveau influences, rich symbolism related to its meaning. 
Keywords: ${card.uprightKeywords.join(', ')}. 
The image should be vertical. Do not include any text, letters, or borders on the card art itself.`;

  try {
    const response = await aiInstance.models.generateImages({
      model: 'imagen-4.0-generate-001',
      prompt: prompt,
      config: {
        numberOfImages: 1,
        outputMimeType: 'image/png',
        aspectRatio: '3:4',
      },
    });

    if (response.generatedImages && response.generatedImages.length > 0) {
      const base64ImageBytes: string = response.generatedImages[0].image.imageBytes;
      return `data:image/png;base64,${base64ImageBytes}`;
    } else {
      throw new Error("No image was generated by the API.");
    }
  } catch (error) {
    const friendlyMessage = parseGeminiError(error, `Failed to generate image for ${card.name}.`);
    throw new Error(friendlyMessage);
  }
};

export const identifyCardFromImage = async (base64Image: string): Promise<string> => {
  const aiInstance = ensureAi();
  const imageParts = base64Image.split(',');
  if (imageParts.length !== 2) {
    throw new Error("Invalid base64 image format provided.");
  }
  const mimeType = imageParts[0].match(/:(.*?);/)?.[1] || 'image/jpeg';
  const imageData = imageParts[1];

  const imagePart: Part = {
    inlineData: {
      mimeType,
      data: imageData,
    },
  };
  const textPart: Part = {
    text: "Identify the tarot card in this image. Respond in JSON format with a single key 'cardName' containing the card's full name. For example: {\"cardName\": \"The Fool\"}",
  };

  const contents: Content = { parts: [imagePart, textPart] };

  try {
    const response = await aiInstance.models.generateContent({
      model: 'gemini-2.5-flash',
      contents,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            cardName: {
              type: Type.STRING,
              description: "The identified name of the tarot card."
            },
          },
          required: ["cardName"]
        },
      },
    });
    const result = JSON.parse(response.text);
    if (result && typeof result.cardName === 'string') {
      return result.cardName.trim();
    } else {
      throw new Error("AI response did not contain a valid card name.");
    }
  } catch (error) {
    if (error instanceof SyntaxError) {
        throw new Error("The AI returned an unexpected response format. Please try again.");
    }
    const friendlyMessage = parseGeminiError(error, "Failed to identify the card from the provided image.");
    throw new Error(friendlyMessage);
  }
};


function formatCardsForPrompt(drawnCards: DrawnCard[]): string {
  return drawnCards.map((c, i) => 
    `Card ${i + 1}: ${c.card.name} (${c.isReversed ? 'Reversed' : 'Upright'})`
  ).join('\n');
}

export const getInterpretation = async (
  drawnCards: DrawnCard[],
  spread: Spread,
  question: string,
  almanacInfo: AlmanacInfo
): Promise<{ overall: string; cards: { cardName: string; meaning: string }[] }> => {
  const aiInstance = ensureAi();
  const cardDetails = formatCardsForPrompt(drawnCards);
  const positionDetails = spread.positions.map((p, i) => `Position ${i+1} (${p.title}): ${p.description}`).join('\n');
  const userQuestion = question ? `The user's question is: "${question}"` : "The user has not provided a specific question; this is a general reading.";

  const almanacContext = `
**Contextual Information:**
- **Lunar Phase:** ${almanacInfo.lunarPhase}
- **Season:** ${almanacInfo.season}
- **Holiday/Sabbat:** ${almanacInfo.holiday || 'None'}

Please subtly weave these contextual elements into the interpretation where they feel relevant to add depth and nuance.
`;

  const contents = `
You are a wise and compassionate Tarot guide. Your tone should be empowering, insightful, and slightly mystical, as if sharing sacred knowledge with a trusted friend. Avoid overly dramatic or fortune-teller language. Focus on providing gentle guidance, highlighting opportunities for growth, and framing challenges as lessons. The interpretation should feel personal, supportive, and deeply connected to the cards' symbolism.

**Reading Details:**
- **Spread:** ${spread.name}
- **Question/Focus:** ${userQuestion}
${almanacContext}
**Cards Drawn:**
${cardDetails}

**Spread Positions:**
${positionDetails}

Please provide an interpretation in JSON format. The JSON object should have two keys:
1.  "overall": A summary of the reading's main message (2-3 sentences).
2.  "cards": An array of objects, one for each card drawn. Each object should have:
    - "cardName": The name of the card (e.g., "The Fool").
    - "meaning": An interpretation of that card in its specific position within the spread, considering the user's question, the other cards, and the contextual information provided. Keep this to 2-4 sentences.

Do not include any introductory or concluding text outside of the JSON structure.
`;

  try {
    const response = await aiInstance.models.generateContent({
      model: "gemini-2.5-flash",
      contents,
      config: {
        responseMimeType: "application/json",
        responseSchema: {
          type: Type.OBJECT,
          properties: {
            overall: {
              type: Type.STRING,
              description: "A summary of the reading's main message."
            },
            cards: {
              type: Type.ARRAY,
              description: "An array of interpretations for each card drawn.",
              items: {
                type: Type.OBJECT,
                properties: {
                  cardName: {
                    type: Type.STRING,
                    description: "The name of the card."
                  },
                  meaning: {
                    type: Type.STRING,
                    description: "The interpretation of the card in its position."
                  }
                },
                required: ["cardName", "meaning"]
              }
            }
          },
          required: ["overall", "cards"]
        },
      },
    });

    const jsonText = response.text;
    const result = JSON.parse(jsonText);

    if (result && result.overall && Array.isArray(result.cards)) {
      return result;
    } else {
      throw new Error("Invalid JSON structure received from API.");
    }

  } catch (error) {
    if (error instanceof SyntaxError) { // JSON.parse error
        throw new Error("The AI returned an unreadable response. This might be a temporary issue. Please try again.");
    }
    const friendlyMessage = parseGeminiError(error, "The Tarot spirits are busy. Please try again in a moment.");
    throw new Error(friendlyMessage);
  }
};